c
DICTIONARY[key]
message
c
data
prompt_key
c
DICTIONARY[key.to_sym]
key
DICTIONARY
DICTIONARY[key]
c
data
prompt_key
c
data[data.keys[0]]
data.keys[0]
data[data.keys.pick]
data[data.keys.first]
data.keys.first
data.keys
data.keyss
data
c
message
response
e
c
params['putData']
=> 12:         core_info.update!(about_text: params['putData']
exit
params
 params['data']
c
params['data']
params
params['data']['message']
core_info
c
CoreInfo.find(@id)
@id = JwtHelper.decrypt(params[:token])
params
@id
@i
c@i
c
core_info.update(about_text: params['data']['message'])
core_info.update(params['data']['message'])
core_info
c
params['token']
params['data']['message']
params['data']['message]
params['data']
params
c
params
c
params['data']
params
c
params
c
params
c
exit
e
c
e
c
exit
e
c
e
c
e
c
data
OpenAiService.new(MARKETING_CONSULTANT_PROMPT, data).call
data
c
response
c
 data = JSON.parse(request.body.read)
params['_json']
params
c
object.about_text
c
CoreInfo.find_or_create_by(user: current_user)
c
exit
exig
resource.core_infos.first.about_text
resource.core_infos.about_text
resource.core_infos
resource
c
JSON.parse(response)['new_text']
response
c
response
c
response
c
JSON.parse(response)
response
c
response
c
JSON.parse(response)['new_text']
JSON.parse(response)
c
feed_to_chat_gpt(message)
c
feed_to_chat_gpt(about)
exit
answer
pp response
response
answer = response.dig("choices", 0, "message", "content")
n
c
OpenAi.complete("#{prompt}#{section}")
c
response = OpenAi.complete("#{prompt}#{section}")
c
#{prompt}#{section}
 OpenAi.complete("#{prompt}#{section}")
response = OpenAi.complete("#{prompt}#{section}")
c
OpenAi.complete("#{prompt}#{section}")
c
"#{prompt}#{section}"
response = OpenAi.complete("#{prompt}#{section}")
exit
OpenAi.complete("#{prompt}#{section}")
response
n
c
response = OpenAi.complete("#{prompt}#{section}")
exit
response.dig("choices", 0, "message", "content")
exit
ChatGPT::Client.new(ENV['OPENAI_API_KEY']).methods
ChatGPT::Client.new(ENV['OPENAI_API_KEY'])
ChatGPTClient.instance.methods
ChatGPTClient.methods
ChatGPTClient.list_models
ChatGPTClient.instance.list_models
c
e.response
n
ChatGPTClient.instance.completions(prompt)
c
e.response
n
 ChatGPTClient.instance.completions(prompt, params)
c
e.response
n
ChatGPTClient.instance.completions(prompt, params)
exit
 e.response
n
ChatGPTClient.instance.completions(prompt, params)
ChatGPTClient.instance.completions(prompt, params
exit
e.response
e
n
e
n
c
ChatGPT::Client.new(ENV['OPENAI_API_KEY']).completions(prompt)
ChatGPT::Client.new(ENV['OPENAI_API_KEY']).completion(prompt)
ChatGPT::Client.new(ENV['OPENAI_API_KEY'])
ENV['OPENAI_API_KEY']
ChatGPTClient.instance.completions(prompt)
prompt = "Experienced Software Engineer with a demonstrated history of working in the computer software industry. Skilled in Ruby on Rails, React.js, and other programming languages."
ChatGPTClient.instance.completions(prompt)
exit
ChatGPTClient.instance.completions(prompt)
c
params
params[:id]
c
params[:id]
c
params
params[:id]
 params[:id]
c
encrypted_id
params[:id]
c
exit
CoreInfo.first
@core_info
params[:id]
c
n
serialized_author
n
@author
n
params[:id]
c
params[:id]
c
params[:id]
c
n
c
Author.find(params[:id])
Author.find(params{:id})
params[:id]
c
n
author
c
author_path(temporary_token)
url_for(controller: 'authors', action: 'show', id: temporary_token)
url_for(controller: './../../authors', action: 'show', id: temporary_token)
c
url_for(controller: './../../authors_controller', action: 'show', id: temporary_token)
c
url_for(controller: './../../authors_controller.rb', action: 'show', id: temporary_token)
c
url
c
temporary_token
c
n
c
JwtHelper.decrypt(params[:token])
c
JwtHelper.decrypt(params[:token])
params[:token]
params
c
params
c
params[:id]
c
JwtHelper.decrypt(params[:token])
params[:token]
JwtHelper.decrypt(params[:token])
id
c
params
c
@token
token
c
user.try(:admin?)
